#include "serializer.hpp"

#include <fstream>
#include <unordered_set>

#include "serializer.class.hpp"
#include "serializer.enum.hpp"
#include "serializer.function.hpp"

using namespace std;
using namespace reflang;

namespace
{
	void AutoGenComment(ostream& o)
	{
		o << R"(// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!! This file is auto-generated by Reflang. !!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
)";
	}

	void BeginHeader(
			ostream& o,
			const serializer::Options& options,
			const std::vector<std::unique_ptr<TypeBase>>& types)
	{
		AutoGenComment(o);
		o << R"(#include <string>

)";
		o << options.include_path << "\n";

		// Generate unique list of includes.
		unordered_set<string> headers;
		for (const auto& type : types)
		{
			headers.insert(type->GetFile());
		}
		for (const auto& header : headers)
		{
			o << "#include \"" << header << "\"\n";
		}

		o << R"(
namespace reflang
{

)";
	}

	void EndHeader(ostream& o)
	{
		o << "}  // namespace reflang\n";
	}

	void BeginSources(ostream& o, const serializer::Options& options)
	{
		AutoGenComment(o);
		if (!options.out_cpp_path.empty())
		{
			o << "#include \"" << options.out_hpp_path << "\"\n";
		}
		o << R"(
#include <algorithm>
#include <cassert>
#include <stdexcept>
#include <type_traits>

namespace reflang
{

)";
	}

	void EndSources(ostream& o)
	{
		o << "}  // namespace reflang\n";
	}
}  // namespace

void serializer::Serialize(
		const std::vector<std::unique_ptr<TypeBase>>& types,
		const Options& options)
{
	std::unique_ptr<ofstream> fout_hpp;
	std::unique_ptr<ofstream> fout_cpp;
	ostream* out_hpp = &cout;
	ostream* out_cpp = &cout;

	if (!options.out_hpp_path.empty())
	{
		fout_hpp = make_unique<ofstream>(options.out_hpp_path.c_str());
		out_hpp = fout_hpp.get();
	}

	out_cpp = out_hpp;
	if (!options.out_cpp_path.empty())
	{
		fout_cpp = make_unique<ofstream>(options.out_cpp_path.c_str());
		out_cpp = fout_cpp.get();
	}

	BeginHeader(*out_hpp, options, types);
	for (const auto& type : types)
	{
		switch (type->GetType())
		{
		case TypeBase::Type::Enum:
			SerializeEnumHeader(*out_hpp, static_cast<const Enum&>(*type));
			break;
		case TypeBase::Type::Function:
			SerializeFunctionHeader(*out_hpp, static_cast<const Function&>(*type));
			break;
		case TypeBase::Type::Class:
			SerializeClassHeader(*out_hpp, static_cast<const Class&>(*type));
			break;
		}
		*out_hpp << "\n\n";
	}
	EndHeader(*out_hpp);

	BeginSources(*out_cpp, options);
	for (const auto& type : types)
	{
		switch (type->GetType())
		{
		case TypeBase::Type::Enum:
			SerializeEnumSources(*out_cpp, static_cast<const Enum&>(*type));
			break;
		case TypeBase::Type::Function:
			SerializeFunctionSources(*out_cpp, static_cast<const Function&>(*type));
			break;
		case TypeBase::Type::Class:
			SerializeClassSources(*out_cpp, static_cast<const Class&>(*type));
			break;
		}
		*out_cpp << "\n\n";
	}
	EndSources(*out_cpp);
}
