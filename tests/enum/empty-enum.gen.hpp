// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!! This file is auto-generated by Reflang. !!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#include <algorithm>
#include <cassert>
#include <stdexcept>
#include <string>

#include "lib/reflang.hpp"

namespace reflang
{

template <>
struct Enum<EmptyEnum> : public IEnum
{
	using EnumType = EmptyEnum;

	struct ConstIterator
	{
		EnumType operator*() { return value_; }

		ConstIterator& operator++()
		{
			assert(false);
			return *this;
		}

		ConstIterator operator++(int)
		{
			auto tmp = *this;
			operator++();
			return tmp;
		}

		ConstIterator& operator--()
		{
			assert(false);
			return *this;
		}

		ConstIterator operator--(int)
		{
			auto tmp = *this;
			operator--();
			return tmp;
		}

		bool operator==(const ConstIterator& o) const
		{
			return ((last_ && o.last_) || (value_ == o.value_));
		}

		bool operator!=(const ConstIterator& o) const
		{
			return !(*this == o);
		}

		EnumType value_;
		bool last_ = true;
	};

	struct IteratorContainer
	{
		ConstIterator begin() const
		{
			return end();
		}

		ConstIterator end() const
		{
			return ConstIterator();
		}
	};

	static IteratorContainer Iterate()
	{
		return IteratorContainer();
	}

	static bool TryTranslate(const std::string& s, EnumType& value)
	{
		return false;
	}

	static std::string Translate(EnumType e)
	{
		return std::string();
	}
	
	const std::string& GetName() const override
	{
		static const std::string name = "EmptyEnum";
		return name;
	}

	std::vector<std::string> GetStringValues() const override
	{
		std::vector<std::string> values;
		values.reserve(0);
		for (const auto& value : this->Iterate())
		{
			values.push_back(this->Translate(value));
		}
		return values;
	}

	std::vector<int> GetIntValues() const override
	{
		std::vector<int> values;
		values.reserve(0);
		for (const auto& value : this->Iterate())
		{
			values.push_back(static_cast<int>(value));
		}
		return values;
	}

	bool TryTranslate(const std::string& value, int& out) override
	{
		EnumType tmp;
		bool result = this->TryTranslate(value, tmp);
		if (result)
		{
			out = static_cast<int>(tmp);
		}
		return result;
	}

	bool TryTranslate(int value, std::string& out) override
	{
		return false;
	}
};


template <>
struct Enum<EmptyCEnum> : public IEnum
{
	using EnumType = EmptyCEnum;

	struct ConstIterator
	{
		EnumType operator*() { return value_; }

		ConstIterator& operator++()
		{
			assert(false);
			return *this;
		}

		ConstIterator operator++(int)
		{
			auto tmp = *this;
			operator++();
			return tmp;
		}

		ConstIterator& operator--()
		{
			assert(false);
			return *this;
		}

		ConstIterator operator--(int)
		{
			auto tmp = *this;
			operator--();
			return tmp;
		}

		bool operator==(const ConstIterator& o) const
		{
			return ((last_ && o.last_) || (value_ == o.value_));
		}

		bool operator!=(const ConstIterator& o) const
		{
			return !(*this == o);
		}

		EnumType value_;
		bool last_ = true;
	};

	struct IteratorContainer
	{
		ConstIterator begin() const
		{
			return end();
		}

		ConstIterator end() const
		{
			return ConstIterator();
		}
	};

	static IteratorContainer Iterate()
	{
		return IteratorContainer();
	}

	static bool TryTranslate(const std::string& s, EnumType& value)
	{
		return false;
	}

	static std::string Translate(EnumType e)
	{
		return std::string();
	}
	
	const std::string& GetName() const override
	{
		static const std::string name = "EmptyCEnum";
		return name;
	}

	std::vector<std::string> GetStringValues() const override
	{
		std::vector<std::string> values;
		values.reserve(0);
		for (const auto& value : this->Iterate())
		{
			values.push_back(this->Translate(value));
		}
		return values;
	}

	std::vector<int> GetIntValues() const override
	{
		std::vector<int> values;
		values.reserve(0);
		for (const auto& value : this->Iterate())
		{
			values.push_back(static_cast<int>(value));
		}
		return values;
	}

	bool TryTranslate(const std::string& value, int& out) override
	{
		EnumType tmp;
		bool result = this->TryTranslate(value, tmp);
		if (result)
		{
			out = static_cast<int>(tmp);
		}
		return result;
	}

	bool TryTranslate(int value, std::string& out) override
	{
		return false;
	}
};


}  // namespace reflang
